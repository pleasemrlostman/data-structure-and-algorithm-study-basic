# 동적 프로그래밍 - 메모이제이션

## 서론
우리는 이전에 재귀를 배웠다. 재귀를 이용해 큰 문제를 작은 문제로 분할해서 해결했고 이를 `분할정복`이라고 했다.<br>
하지만 재귀를 사용하면 함수가 호출되어 콜스택의 영역을 차지하는 단점 외에도 성능에 크게 영향을 미치는 단점이 있다<br>

수학에는 `피보나치 수열`이라는 것이 있다. `피보나치 수열`은 `1`과 `1`로 시작한다. 이제 이 두 수를 가지고 무한대의 수를 만들거다.<br>
먼저 첫 번쨰 수와 두 번째 수를 더해서 세 번째 수를 구한다. 네 번째 수는 두 번째 수와 세 번째 수를 더해서 구한다. 다섯 번재 수는 세 번째 수와 네 번째 수를 더해서 구한다. 이제 이 반복되는 로직을 재귀함수로 구현해 보겠다.<br>

그리고 함수를 선언하고 구하고 싶은 자릿수의 수를 매개변수로 받습니다.

```js
function fibonacci(n) {
    if(n == 0 || n == 1) return n
    return fibonacci(n - 2) + fibonacci(n - 1)
}
```
하지만 완성된 이 재귀 함수는 성능이 별로 좋지 못하다.<br>
우리가 만든 함수는 같은 계산을 하는 경우가 많이 발생한다. 그러면 중복계산으로 인해 낭비되는 시간을 어떻게 줄일 수 있을까?<br>
정답은 간단하다 계산 결과를 저장하는 것 이다. 그리고 같은 계산이 필요할 때 저장된 결과를 사용한다. 이러한 문제를 해결해 줄 수 있는게 `메모이제이션`이다.<br>

## 정의

`메모이제이션`은 계산 결과를 저장해서 여러 번 계산하지 않도록 하는 기법이다. `fibonacci` 함수를 `메모이제이션` 기법을 이용해 성능을 향상시켜보겠다. 우리는 계산하려는 데이터가 있는지 검색하고 없다면 함수를 호출해 계산을 하고 그 결과를 저장시키면 된다.

## 구현

```js

function fibonacci2(n, memo) {
    if(n == 0 || n == 1) return n // 기존은 동일하게하고
    // 객체(해시테이블)에 해당 값의 계산 결과가 있는지 검색해본다.
    if(memo[n] == null) {
        memo[n] = fibonacci2(n - 2, memo) + fibonacci2(n - 1, memo);
    }
    return memo[n]
}

```