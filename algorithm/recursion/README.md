# 재귀 (recursion)

## 재귀함수

재귀는 어떠한 것을 정의 할 때 자기 자신을 참조하는 것, 우리는 함수를 정의할 때 재귀를 사용하는데 이렇게 재귀적으로 정의 된 함수를 `재귀함수`라고 부릅니다.

```js
function myFunction(number) {
  console.log(number);
  myFunction(number + 1);
}

myFunction(1);
```

해당 함수를 정의하고 실행하면 중지 명령어를 작성한 적 없는데 자동으로 중지된다. 이는 콜스택이라는 메모리 공간이 가득 차서 자동으로 종료된 것이다.<br><br>
해당 함수는 기저 조건(탈출 조건)이 없기 때문에 메모리가 금방 가득 차서 프로그램이 자동으로 종료됩니다.<br>
어떻게 하면 이 재귀함수를 쓸모있게 사용 할 수 있을까?<br><br>
재귀함수는 `탈출 조건`, 즉 `기저 조건`이 반드시 있어야 한다. 즉 자기 자신을 계속 호출하다 특정 조건이 나오면 함수를 종료한다.

```js
function myFunction(number) {
  if (number > 10) return;
  console.log(number);
  myFunction(number + 1);
}

myFunction(1);
```

---

## 콜스택

우리는 재귀함수의 깊은 이해를 위해서 콜스택이라는 개념을 알아야한다.<br>
콜스택은 함수가 호출되면서 올라가는 메모리 영역으로 스택이라고도 부른다.<br>
콜스택은 스택의 특성처럼 먼저 들어오면 나중에 나간다 라는 FILO 특성을 가지고 있다.<br>
함수를 호출하면 이 함수는 콜스택에 올라가게되고<br>
함수가 종료되면 스택에서 제거된다.<br><br>

함수 A와 함수 B를 호출하는 두 가지 상황을 예시로 들겠습니다.

```js
function funcA() {
  let a = 10;
  let b = 5;
  return a + b;
}

function funcB() {
  let a = 10;
  let b = 5;
  return a + b;
}

funcA();
funcB();
```

먼저 A를 호출하면 `funcA()` 함수는 콜스택에 올라가게된다.<br>
그리고 함수 `funcA()`가 종료되면 콜스택에서 제거되고 `funcB()`가 콜스택에 올라가고 함수를 실행한다. 그리고 `funcB()`가 종료되면 스택에서 제거된다.<br>

두 번째 상황은 `funcA`에서 `funcB`를 실행하는 상황이다.

```js
function funcA() {
  let a = 10;
  let b = 5;
  let c = funcB();
  return a + b;
}

function funcB() {
  let a = 10;
  let b = 5;
  return a + b;
}

funcA();
```

먼저 `funcA()`를 호출하면 이 함수는 콜스택에 올라가게 된다. 그리고 `funcA` 를 실행하는 중간에 `funcB` 함수를 만나게되고 `funcA` 함수가 종료되지 않았기 때문에 콜스택에서 제거되지 않는다. 그러면 콜스택에서 `funcA` 위에 `funcB` 함수가 올라가게 된다. 그리고 `funcA` 내부에 있는 `funcB` 가 실행되고 `funcB` 함수는 실행이 끝났기 때문에 콜스택에서 제거된다. 그리고 `funcA` 는 나머지 코드를 실행시키고 콜스택에서 제거된다. 이 콜 스택은 스택 자료구조를 활용한 대표적인 사례이다.

---

## 콜스택에서의 재귀 함수

이전에 만들어 두었던 재귀함수에서 기저 조건에서 `10`이라는 숫자를 `3`으로 변경해준다.

```js
function myFunction(number) {
  if (number > 3) return;
  console.log(number);
  myFunction(number + 1);
}

myFunction(1);
```

가장 먼저 `myFunction(1)` 이 불리면 콜스택에 매개변수 `number`에 `1`이 들어간 `myFunction` 함수가 올라갑니다. 그리고 내부에서 기저 조건을 확인하는데 if문이 거짓이기 때문에 콘솔을 찍고 `1` 에 `1`을 더한 `2`를 매개변수로 넘기며 `myFunction` 함수를 호출합니다. 그러면 새로호출한 `myFunction` 의 `number` 는 `2`가 되는데 현재 함수가 종료되지 않았던 상태에서 호출하기 때문에 콜스택에는 `myFunction(1)` 이 제거되지 않고 `myFunction(2)` 가 올라갑니다. 그러면 `myFunction(2)` 가 실행되면서 기저 조건을 확인하고 if 문이 거짓이기 때문에 함수를 종료하지 않습니다. 다시 화면에 `2`를 출력하고 `myFunction` 을 호출하는데 `2`에 `1`을 더한 `3`을 매개변수로 넘겨줍니다. 이전 상황과 마찬가지로 이 함수는 아직 종료되지 않은 상태에서 `myFunction(3)` 을 호출하기 때문에 콜스택에 `myFunction(3)` 가 올라갑니다. `myFunction(3)`도 이전 상황과 마찬가지로 if 문이 거짓이므로 `3` 을 출력하고 `myFunction` 을 호출하는데 `3`에 `1`을 더한 `4`를 매개변수로 넘겨주며 호출합니다. `myFunction(4)`도 콜스택에 올라갑니다. `myFunction(4)` 에서는 if 문이 참이된다. 이 함수는 if 문에서 return을 하고 종료된다. 그러면 콜 스택에서 `myFunction(4)` 는 제거되고 `myFunction(3)` 로 넘어가지만 `myFunction(3)` 는 더이상 코드가 없으므로 더이상 실행하지 않고 종료된다. 그리고 `myFunction(2)`로 넘어가고 마찬가지로 코드가 없으므로 종료되고 `myFunction(1)` 으로 넘어가고 코드가 더 이상 없으므로 콜스택에서 제거된다.<br><br>

이렇게 재귀함수는 호출할 때마다 콜스택의 영역을 차지하게 된다. 우리가 이전에 기저 조건이 없을 때 `11111`까지(혹은 조금 더 이상) 출력되고 종료된 이유는 바로 이 콜스택이 계속 쌓여서 메모리가 부족해졌기 때문입니다.<br>
이 때문에 for 문으로 해결할 수 있는 작업을 재귀함수로 해결하면 더 비효율적인 상황이많다 `(재귀함수가 더 많은 메모리 공간을 차지함)`<br><br>

그렇다면 왜 재귀함수를 쓸까? 재귀함수는 for 문을 대신하려고 쓰이기보다는 더 복잡한 문제를 쉽게해결하기 위해 사용한다.<br>
재귀함수를 이용하면 해결하기 힘든 문제를 쉽게 해결하는 상황이 많은데 대표적으로 `팩토리얼`이 있다.

---

## 팩토리얼

팩토리얼을 구현하면서 재귀함수의 강력함을 알아보자<br><br>

수학에는 팩토리얼이라는 것이 있습니다.<br><br>

팩토리얼은 `n`이 주어질 때 `1`부터 `n` 까지 모든 수의 곱을 말합니다. 이러한 팩토리얼을 재귀함수로 구현해보도록 하겠다<br><br>
재귀함수는 처음 구현하면 어려운데 재귀함수를 쉽게 구현하는 방법은 재귀함수내에서 자기자신을 호출할 때 이 함수가 벌써 구현이 되어있다고 가정하는 것입니다.
`number`로 `5`가 들어온 상황에서 `5!`을 구현하는 방법은 `5 x 4!`을 구현하는 것과 같습니다. 왜냐하면 `4!`이 `4 x 3 x 2 x 1` 이기 때문이다. `팩토리얼` 함수가 이미 구현됐다고 생각하고 `5 * factorial(4)` 을 호출하면 됩니다

```js
function factorial(number) {
  if (number == 1 || number == 0) {
    return 1;
  } else {
    return number * factorial(number - 1);
  }
}
```

기저 조건은 number가 1이되면 팩토리얼이 종료된다. 그리고 `0!`은 `1`이기 때문에 같이 기저조건에 넣어주겠다.

---

## 재귀적으로 생각하기

재귀를 배웠더라도 재귀적으로 생각하는 건 쉬운 일이 아니다. 그러므로 재귀의 여러 가지 패턴을 분석하고 재귀함수를 만났을 때 어떤 종류의 재귀함수인지 구분해보자<br><br>

### 패턴 1

`1 ~ 10` 더하는 함수를 for 문과 재귀함수를 이용해서 구현했다.

```js
// for 문
for (let i = 1; i < 11; i++) {
  console.log(i);
}

// 재귀함수
function myFunction(number) {
  if (number > 10) return;
  console.log(number);
  myFunction(number + 1);
}
```

단순히 반복실행을 재귀로 구현하면 반복문으로 구현했을 때보다 크게 이점이 되는 부분이 없다. 오히려 콜스택에 공간을 많이 차지해 성능은 for 문보다 좋지 않다.

---

### 패턴 2

하위 문제의 결과를 기반으로 현재 문제를 계산하는 것 우리는 이전에 팩토리얼 함수 구현을 통해알아봤다

```js
return number * factorial(number - 1);
```

만약 `5!` 이라면 `5 x 4!` 을 하는 것이다. 즉 하위 문제의 결과 `4!`을 기반으로 현재문제 `5!`을 계산하는 것이다.
사실 팩토리얼은 재귀함수를 사용하지 않고 for 문을 이용해서 구현할 수도 있다.

```js
function factorial(number) {
  let sum = 1;
  for (let i = 1; i <= number; i++) {
    sum *= i;
  }
  return sum;
}
```

단순하게 보면 for 문을 이용한 것은 `1`부터 올라가는 것이고 재귀함수를 이용한 것은 반대로 계산하는 것처럼 보입니다. 하지만 재귀함수를 이용할 떄 하위 문제의 결과를 기반으로 현재 문제를 계산한다는 것은 굉장히 큰 차이입니다.

```js
return number * factorial(number - 1); // 상위 문제를 해결하는데 하위 문제가 쓰이는 것이 중요하다.
```

for 문을 이용해서 계산하는 방식을 상향식 계산이라고 한다. 반대로 재귀를 이용해서 하위문제의 결과를 기반으로 현재 문제를 계산하는 방식을 하향식 계산이라고 합니다. 재귀를 이용한다고해서 모두 하향식 계산이라고 부르지는 않습니다. 사실 재귀를 이용해서 상향식 계산을 할 수도 있다.

```js
function factorial2(number, i = 1, sum = 1) {
  if (i > number) return sum;
  return factorial2(number, i + 1, sum * i);
}
```

지금보는 이 함수는 재귀함수이지만 하향식 계산방식이 아니라 for 문과 마찬가지로 상향식 계산방식이다. 재귀함수의 진정한 강점은 하향식 계산에서 발휘된다. 따라서 지금 구현한 방식은 재귀함수의 위력을 나타낼 수 없을뿐더러 for 문으로 구현한 것보다 성능도 좋지 못하다. 상향식 계산 방식은 for 문이나 재귀함수를 이용해서 구현할 수 있지만 하향식 계산방식은 오직 재귀 함수로만 구현할 수 있다. 우리는 앞으로 재귀를 하향식 계산에만 사용할 것입니다. 그게 재귀를 사용하는 이유이기 때문이다.

---

### 배열의 합 (하향식)

우리는 하향식 계산을 하기 위해서는 하위 문제의 결과를 기반으로 현재 문제를 계산해야 한다는 것을 알고있다.<br>
만약 1부터 5까지 들어있는 배열의 합을 구한다고 할 떄 `[1, 2, 3, 4, 5]` 여기서 하위 문제는 1부터 4까지 들어있는 배열의 합을 구하는 문제이다. 해당 하위문제에 마지막 5만 더하면 문제는 해결된다.

이제 우리가 하향식으로 재귀함수를 구현하기 위해서 이 `sumArray` 함수가 벌써 구현이 완료되었다고 가정하겠습니다.<br>

```js
function sumArray(arr) {
  if (arr.length == 1) return arr[0];
  return sumArray(arr.slice(0, -1)) + arr[arr.length - 1];
}
```

배열을 0번 인덱스부터 마지막 인덱스 한 칸 전 까지 자른 배열의 합을 말한다. <br> 그리고 이 결과에 배열의 마지막 원소를 더해주면 끝난다. <br> 이제 마지막 조건 기저 조건을 넣어줘야 한다. <br>

배열의 원소가 하나 일때는 한개가 전체의 합이니 해당 원소를 리턴해주면 된다.<br>
이렇게 하위문제의 결과를 기반으로 현재 문제를 계산하면 하향식 계산방식으로 재귀함수를 작성한 것이다.

---

### 문자열 길이 계산 (strLength())

```js
function strLength(arr) {
  if (arr[0] == null) return 0;
  return strLength(arr.slice(0, -1)) + 1;
}

let str = "abced";
let len = strLength(str);
console.log(len);
```

재귀함수로 문자열의 길이를 계산하기 위해서는 하위열을 생각해야한다. 하위열은 구하려는 문자열의 마지막 원소를 제외한 나머지 부분이다. 만약 문자열이 `abced`면 `0`번 인덱스부터 `3`번 인덱스까지 문자열의 길이는 해결됐다고 가정하고 이 결과값으로 나머지 길이를 구해주면 된다. 문자가 하나있기 때문에 `1`을 더해주면 된다.<br>

현재 배열에서 마지막 원소를 뺀 값, 즉 `0`번 인덱스부터 `3`번 인덱스까지 문자열을 재귀함수로 호출하고 기저 조건으로 배열의 `0`번 인덱스가 없다면 문자열이 없는 것이므로 길이는 `0`이다<br>

재귀함수는 우리가 살아오면서 비슷한 생각을 할 일이 거의 없기 때문에 이해가 힘들 수 있다.

---

### 지수함수

밑이 2이고 지수가 5면 2를 다섯 번 곱하라는 의미이다.<br>

우리가 구현할 지수함수는 밑을 `x`로, 지수를 `n`으로 정의하겠습니다. 함수이름은 `power`로 정의하고 매개변수는 `x`와 `n`으로 만들어준다. <br>
만약 2의 5승이라면 이때 하위문제는 2의 4승이다. 여기서 2를 한 번만 더 곱해주면 문제가 해결된다.

```js
function power(x, n) {
  if (n == 0) return 1;
  return power(x, n - 1) * x;
}

console.log(power(2, 5));
```

---

### 하노이의 탑

```js

function hanoi(count, from, to, temp) {
  if(count == 0) return
  hanoi(count - 1, from, temp, to)   
  console.log(`원반, ${count}을 ${from}에서 ${to}로 이동`)
  hanoi(count - 1, temp, to, from) 
}

hanoi(3, "A", "C", "B")
```

3개의 기둥을 기둥 `A`에서 시작해서 `C`로 옮기는데 `B`도 사용된다는 의미이다.

자 이제 인자를 대입해가면서 직접 어떤식으로 작동하는지 확인해 보도록하자 우선 `hanoi(3, "A", "C", "B")` 코드를 넣어보자


```js
function hanoi(3, "A", "C", "B") {
  if(3 == 0) return
  hanoi(3 - 1, "A", "B", "C")   
  console.log(`원반, ${3}을 ${A}에서 ${C}로 이동`)
  hanoi(3 - 1, "B", "C", "A") 
}
```
자 이렇게 코드가 실행된다 그러면 한 줄 한 줄 읽어보면 `if(3 == 0) return` 해당 if절은 `false` 이므로 `hanoi(2, "A", "B", "C")` 코드로 이동한다. 그러면

```js
function hanoi(2, "A", "B", "C") {
  if(2 == 0) return
  hanoi(2 - 1, "A", "C", "B")   
  console.log(`원반, ${2}을 ${A}에서 ${B}로 이동`)
  hanoi(2 - 1, "C", "B", "A") 
}
```
함수가 실행된다 자 그런데 `if(2 == 0) return` 도 `false`이기 때문에 `hanoi(2 - 1, "A", "C", "B")` 해당 함수로 이동한다 그러면


```js
function hanoi(1, "A", "C", "B") {
  if(1 == 0) return
  hanoi(1 - 1, "A", "B", "C")   
  console.log(`원반, ${1}을 ${A}에서 ${C}로 이동`)
  hanoi(1 - 1, "B", "C", "A") 
}
```
함수가 실행된다 자 그런데 `if(1 == 0) return` 도 `false`이기 때문에 `hanoi(1 - 1, "A", "C", "B")` 해당 함수로 이동한다<br>
여기서! 특이점이 발생한다. `hanoi(1 - 1, "A", "B", "C")` 을 실행시키면 함수 내부에서 `if(0 == 0)`이 `true`이기 때문에 바로 그 다음 함수가 실행된다 그러면 `console.log(원반, 1을 A에서 C로 이동)` 이 콘솔에 찍히고 `hanoi(1 - 1, "B", "C", "A")` 해당 함수가 시작되지만 바로 return되기 때문에

```js
function hanoi(2, "A", "B", "C") {
  if(2 == 0) return
  hanoi(2 - 1, "A", "C", "B")   
  console.log(`원반, ${2}을 ${A}에서 ${B}로 이동`)
  hanoi(2 - 1, "C", "B", "A") 
}
```
함수로 복귀한다 그러면 `hanoi(2 - 1, "A", "C", "B")` 는 완료했으니 `console.log(원반, 2을 A에서 B로 이동)` 가 콘솔에 찍힌다.

그리고 `hanoi(2 - 1, "C", "B", "A")` 함수가 실행되므로

```js
function hanoi(1, "C", "B", "A") {
  if(1 == 0) return
  hanoi(1 - 1, "C", "A", "B")   
  console.log(`원반, ${1}을 ${C}에서 ${B}로 이동`)
  hanoi(1 - 1, "A", "B", "C") 
}
```
if문은 `false` 이므로 아래로 내려갔지만 바로 return되니 함수를 빠져나와서 `console.log(원반, 1을 C에서 B로 이동)`가 콘솔에 찍힌다.

그리고 아래 함수가 시작되는데 return되니 함수를 빠져나와서 원래 호출했던 함수로 돌아온다

```js
function hanoi(2, "A", "B", "C") {
  if(2 == 0) return
  hanoi(2 - 1, "A", "C", "B")   
  console.log(`원반, ${2}을 ${A}에서 ${B}로 이동`)
  hanoi(2 - 1, "C", "B", "A") 
}
```
그런데 해당 함수도 완료됐으니 또 해당 함수를 불렀던 함수로 복귀하면
```js
function hanoi(3, "A", "C", "B") {
  if(3 == 0) return
  hanoi(3 - 1, "A", "B", "C")   
  console.log(`원반, ${3}을 ${A}에서 ${C}로 이동`)
  hanoi(3 - 1, "B", "C", "A") 
}
```
`hanoi(3 - 1, "A", "B", "C")` 해당 함수가 호출됐으니 `console.log(원반, 3을 A에서 C로 이동)` 이 콘솔에 찍힌다. 

그리고 `hanoi(3 - 1, "B", "C", "A")` 함수가 호출되면

```js
function hanoi(2, "B", "C", "A") {
  if(2 == 0) return
  hanoi(2 - 1, "B", "A", "C")   
  console.log(`원반, ${2}을 ${B}에서 ${C}로 이동`)
  hanoi(2 - 1, "A", "C", "B") 
}
```
함수가 호출된다 if문을 빠져나와 `hanoi(2 - 1, "B", "A", "C")`함수가 실행되면

```js
function hanoi(1, "B", "A", "C") {
  if(1 == 0) return
  hanoi(1 - 1, "B", "C", "A")   
  console.log(`원반, ${1}을 ${B}에서 ${A}로 이동`)
  hanoi(1 - 1, "C", "A", "B") 
}
```

if문을 빠져나와 아래 함수로 이동해도 바로 return되니 `console.log(원반, 1을 B에서 A로 이동)` 해당 부분이 콘솔에 찍힌다.
그리고 아래 함수는 바로 return 되므로 원래 함수로 돌아오면
```js
function hanoi(2, "B", "C", "A") {
  if(2 == 0) return
  hanoi(2 - 1, "B", "A", "C")   
  console.log(`원반, ${2}을 ${B}에서 ${C}로 이동`)
  hanoi(2 - 1, "A", "C", "B") 
}
```
`hanoi(2 - 1, "B", "A", "C")` 함수는 실행 했으므로 `console.log(원반, 2을 B에서 C로 이동)` 가 콘솔에 찍힌다 그리고 `hanoi(2 - 1, "A", "C", "B")` 함수가 실행되면

```js
function hanoi(1, "A", "C", "B") {
  if(1 == 0) return
  hanoi(1 - 1, "A", "B", "C")   
  console.log(`원반, ${1}을 ${A}에서 ${C}로 이동`)
  hanoi(1 - 1, "B", "C", "A") 
}
```
해당 함수가 실행되므로 return을 통과하고 다음 함수도 바로 return되므로 통과하고 `console.log(원반, 1을 A에서 C로 이동)`이 콘솔에 찍히고 다음 함수가 실행되지만 리턴되므로 원래 해당함수로 돌아가자

```js
function hanoi(2, "B", "C", "A") {
  if(2 == 0) return
  hanoi(2 - 1, "B", "A", "C")   
  console.log(`원반, ${2}을 ${B}에서 ${C}로 이동`)
  hanoi(2 - 1, "A", "C", "B") 
}
```
그런데 해당함수도 종료됐으니까 원래함수로 돌아가면

```js
function hanoi(3, "A", "C", "B") {
  if(3 == 0) return
  hanoi(3 - 1, "A", "B", "C")   
  console.log(`원반, ${3}을 ${A}에서 ${C}로 이동`)
  hanoi(3 - 1, "B", "C", "A") 
}
```
해당 함수인데 해당함수도 종료됐으니 `hanoi(3, "A", "C", "B")` 해당 함수가 끝났다.


