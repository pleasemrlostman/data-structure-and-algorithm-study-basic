# 재귀 (recursion)

## 재귀함수

재귀는 어떠한 것을 정의 할 때 자기 자신을 참조하는 것, 우리는 함수를 정의할 때 재귀를 사용하는데 이렇게 재귀적으로 정의 된 함수를 `재귀함수`라고 부릅니다.

```js
function myFunction(number) {
  console.log(number);
  myFunction(number + 1);
}

myFunction(1);
```

해당 함수를 정의하고 실행하면 중지 명령어를 작성한 적 없는데 자동으로 중지된다. 이는 콜스택이라는 메모리 공간이 가득 차서 자동으로 종료된 것이다.<br><br>
해당 함수는 기저 조건(탈출 조건)이 없기 때문에 메모리가 금방 가득 차서 프로그램이 자동으로 종료됩니다.<br>
어떻게 하면 이 재귀함수를 쓸모있게 사용 할 수 있을까?<br><br>
재귀함수는 `탈출 조건`, 즉 `기저 조건`이 반드시 있어야 한다. 즉 자기 자신을 계속 호출하다 특정 조건이 나오면 함수를 종료한다.

```js
function myFunction(number) {
  if (number > 10) return;
  console.log(number);
  myFunction(number + 1);
}

myFunction(1);
```

---

## 콜스택

우리는 재귀함수의 깊은 이해를 위해서 콜스택이라는 개념을 알아야한다.<br>
콜스택은 함수가 호출되면서 올라가는 메모리 영역으로 스택이라고도 부른다.<br>
콜스택은 스택의 특성처럼 먼저 들어오면 나중에 나간다 라는 FILO 특성을 가지고 있다.<br>
함수를 호출하면 이 함수는 콜스택에 올라가게되고<br>
함수가 종료되면 스택에서 제거된다.<br><br>

함수 A와 함수 B를 호출하는 두 가지 상황을 예시로 들겠습니다.

```js
function funcA() {
  let a = 10;
  let b = 5;
  return a + b;
}

function funcB() {
  let a = 10;
  let b = 5;
  return a + b;
}

funcA();
funcB();
```

먼저 A를 호출하면 `funcA()` 함수는 콜스택에 올라가게된다.<br>
그리고 함수 `funcA()`가 종료되면 콜스택에서 제거되고 `funcB()`가 콜스택에 올라가고 함수를 실행한다. 그리고 `funcB()`가 종료되면 스택에서 제거된다.<br>

두 번째 상황은 `funcA`에서 `funcB`를 실행하는 상황이다.

```js
function funcA() {
  let a = 10;
  let b = 5;
  let c = funcB();
  return a + b;
}

function funcB() {
  let a = 10;
  let b = 5;
  return a + b;
}

funcA();
```

먼저 `funcA()`를 호출하면 이 함수는 콜스택에 올라가게 된다. 그리고 `funcA` 를 실행하는 중간에 `funcB` 함수를 만나게되고 `funcA` 함수가 종료되지 않았기 때문에 콜스택에서 제거되지 않는다. 그러면 콜스택에서 `funcA` 위에 `funcB` 함수가 올라가게 된다. 그리고 `funcA` 내부에 있는 `funcB` 가 실행되고 `funcB` 함수는 실행이 끝났기 때문에 콜스택에서 제거된다. 그리고 `funcA` 는 나머지 코드를 실행시키고 콜스택에서 제거된다. 이 콜 스택은 스택 자료구조를 활용한 대표적인 사례이다.

---

## 콜스택에서의 재귀 함수

이전에 만들어 두었던 재귀함수에서 기저 조건에서 `10`이라는 숫자를 `3`으로 변경해준다.

```js
function myFunction(number) {
  if (number > 3) return;
  console.log(number);
  myFunction(number + 1);
}

myFunction(1);
```

가장 먼저 `myFunction(1)` 이 불리면 콜스택에 매개변수 `number`에 `1`이 들어간 `myFunction` 함수가 올라갑니다. 그리고 내부에서 기저 조건을 확인하는데 if문이 거짓이기 때문에 콘솔을 찍고 `1` 에 `1`을 더한 `2`를 매개변수로 넘기며 `myFunction` 함수를 호출합니다. 그러면 새로호출한 `myFunction` 의 `number` 는 `2`가 되는데 현재 함수가 종료되지 않았던 상태에서 호출하기 때문에 콜스택에는 `myFunction(1)` 이 제거되지 않고 `myFunction(2)` 가 올라갑니다. 그러면 `myFunction(2)` 가 실행되면서 기저 조건을 확인하고 if 문이 거짓이기 때문에 함수를 종료하지 않습니다. 다시 화면에 `2`를 출력하고 `myFunction` 을 호출하는데 `2`에 `1`을 더한 `3`을 매개변수로 넘겨줍니다. 이전 상황과 마찬가지로 이 함수는 아직 종료되지 않은 상태에서 `myFunction(3)` 을 호출하기 때문에 콜스택에 `myFunction(3)` 가 올라갑니다. `myFunction(3)`도 이전 상황과 마찬가지로 if 문이 거짓이므로 `3` 을 출력하고 `myFunction` 을 호출하는데 `3`에 `1`을 더한 `4`를 매개변수로 넘겨주며 호출합니다. `myFunction(4)`도 콜스택에 올라갑니다. `myFunction(4)` 에서는 if 문이 참이된다. 이 함수는 if 문에서 return을 하고 종료된다. 그러면 콜 스택에서 `myFunction(4)` 는 제거되고 `myFunction(3)` 로 넘어가지만 `myFunction(3)` 는 더이상 코드가 없으므로 더이상 실행하지 않고 종료된다. 그리고 `myFunction(2)`로 넘어가고 마찬가지로 코드가 없으므로 종료되고 `myFunction(1)` 으로 넘어가고 코드가 더 이상 없으므로 콜스택에서 제거된다.<br><br>

이렇게 재귀함수는 호출할 때마다 콜스택의 영역을 차지하게 된다. 우리가 이전에 기저 조건이 없을 때 `11111`까지(혹은 조금 더 이상) 출력되고 종료된 이유는 바로 이 콜스택이 계속 쌓여서 메모리가 부족해졌기 때문입니다.<br>
이 때문에 for 문으로 해결할 수 있는 작업을 재귀함수로 해결하면 더 비효율적인 상황이많다 `(재귀함수가 더 많은 메모리 공간을 차지함)`<br><br>

그렇다면 왜 재귀함수를 쓸까? 재귀함수는 for 문을 대신하려고 쓰이기보다는 더 복잡한 문제를 쉽게해결하기 위해 사용한다.<br>
재귀함수를 이용하면 해결하기 힘든 문제를 쉽게 해결하는 상황이 많은데 대표적으로 `팩토리얼`이 있다.

---

## 팩토리얼

팩토리얼을 구현하면서 재귀함수의 강력함을 알아보자<br><br>

수학에는 팩토리얼이라는 것이 있습니다.<br><br>

팩토리얼은 `n`이 주어질 때 `1`부터 `n` 까지 모든 수의 곱을 말합니다. 이러한 팩토리얼을 재귀함수로 구현해보도록 하겠다<br><br>
재귀함수는 처음 구현하면 어려운데 재귀함수를 쉽게 구현하는 방법은 재귀함수내에서 자기자신을 호출할 때 이 함수가 벌써 구현이 되어있다고 가정하는 것입니다.
`number`로 `5`가 들어온 상황에서 `5!`을 구현하는 방법은 `5 x 4!`을 구현하는 것과 같습니다. 왜냐하면 `4!`이 `4 x 3 x 2 x 1` 이기 때문이다. `팩토리얼` 함수가 이미 구현됐다고 생각하고 `5 * factorial(4)` 을 호출하면 됩니다

```js
function factorial(number) {
  if (number == 1 || number == 0) {
    return 1;
  } else {
    return number * factorial(number - 1);
  }
}
```

기저 조건은 number가 1이되면 팩토리얼이 종료된다. 그리고 `0!`은 `1`이기 때문에 같이 기저조건에 넣어주겠다.
